<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Processing Engine: 1 - Components</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Processing Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorial.html">Processing Engine Tutorial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">1 - Components </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ch1_1">1.1 - Component Structure</a></li>
<li class="level1"><a href="#ch1_2">1.2 - Component Functions</a><ul><li class="level2"><a href="#newfunc">New Function</a></li>
<li class="level2"><a href="#delfunc">Delete Function</a></li>
<li class="level2"><a href="#updatefunc">Update Function</a></li>
<li class="level2"><a href="#drawfunc">Draw Function</a></li>
<li class="level2"><a href="#collresfunc">Collision Resolution Function</a></li>
</ul>
</li>
<li class="level1"><a href="#ch1_3">1.3 - Component New Function</a><ul><li class="level2"><a href="#typeid">Type Id</a></li>
</ul>
</li>
<li class="level1"><a href="#ch1_4">1.4 - Component Collisions</a><ul><li class="level2"><a href="#collcheck">Collision Checking Functions</a></li>
<li class="level2"><a href="#collresolve">Collision Resolving Functions</a></li>
<li class="level2"><a href="#initcollcomps">INITCOLLCOMPS</a></li>
<li class="level2"><a href="#collfuncreg">Registering Collision Functions</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ch1_1"></a>
1.1 - Component Structure</h1>
<p><a class="el" href="struct_component.html" title="Object Component. ">Component</a> s are the building blocks of a game in Processing <a class="el" href="struct_engine.html" title="Contains Engine data. ">Engine</a>. Most of a game's code will be in <a class="el" href="struct_component.html" title="Object Component. ">Component</a> s.</p>
<p>First of all, <a class="el" href="struct_component.html" title="Object Component. ">Component</a> s are all "substructs" of the <a class="el" href="struct_component.html" title="Object Component. ">Component</a> struct. Now, this isn't true inheritance, since Processing <a class="el" href="struct_engine.html" title="Contains Engine data. ">Engine</a> works with C. Processing <a class="el" href="struct_engine.html" title="Contains Engine data. ">Engine</a> uses pseudo-inheritance, where <a class="el" href="struct_component.html" title="Object Component. ">Component</a> s contain a <a class="el" href="struct_component.html" title="Object Component. ">Component</a> part as their first variable, such that pointers to those <a class="el" href="struct_component.html" title="Object Component. ">Component</a> s can be cast to a <a class="el" href="struct_component.html" title="Object Component. ">Component</a> pointer and be used as a <a class="el" href="struct_component.html" title="Object Component. ">Component</a> struct.</p>
<p>Here is a sample <a class="el" href="struct_component.html" title="Object Component. ">Component</a> that has everything required for a basic <a class="el" href="struct_component.html" title="Object Component. ">Component</a>:</p>
<p><a class="el" href="samplecomp_8h.html">samplecomp.h</a>: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#pragma once</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="component_8h.html">component.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_sample_comp.html">SampleComp</a> {</div><div class="line">    <a class="code" href="struct_component.html">Component</a> <a class="code" href="struct_sample_comp.html#ae2a899666a55707f47953ef45d0bdd86">comp</a>; </div><div class="line"></div><div class="line"></div><div class="line">} <a class="code" href="group___components.html#gadeb36c2560879323a2ec3b8789f18897">SampleComp</a>;</div><div class="line"></div><div class="line"><a class="code" href="struct_sample_comp.html">SampleComp</a> *<a class="code" href="group___components.html#gad6e4817dceea47dee259a975557a7dd9">SampleComp_new</a>();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___components.html#ga24bcba40daa548812854a9add6bb2aa9">_SampleComp_delete</a>(<a class="code" href="struct_sample_comp.html">SampleComp</a> *<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___components.html#gac203db290671527d7884287863a723e7">_SampleComp_update</a>(<a class="code" href="struct_sample_comp.html">SampleComp</a> *<span class="keyword">this</span>);</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___components.html#gabaa2e55440401af61c0efeec874a21dd">_SampleComp_draw</a>(<a class="code" href="struct_sample_comp.html">SampleComp</a> *<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___components.html#gac898ef947fcd43cdb4cf202d50acb61a">_SampleComp_coll_resolve</a>(<a class="code" href="struct_sample_comp.html">SampleComp</a> *<span class="keyword">this</span>, <a class="code" href="struct_component.html">Component</a> *other);</div><div class="line"></div></div><!-- fragment --><p> <a class="el" href="samplecomp_8c.html" title="SampleComp implementation. ">samplecomp.c</a>: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="samplecomp_8h.html">samplecomp.h</a>&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="struct_sample_comp.html">SampleComp</a> *<a class="code" href="group___components.html#gad6e4817dceea47dee259a975557a7dd9">SampleComp_new</a>() {</div><div class="line">    <a class="code" href="struct_sample_comp.html">SampleComp</a> *<span class="keyword">this</span> = malloc(<span class="keyword">sizeof</span>(<a class="code" href="struct_sample_comp.html">SampleComp</a>));</div><div class="line">    this-&gt;comp.typeName = <span class="stringliteral">&quot;SampleComp&quot;</span>;</div><div class="line">    this-&gt;comp.typeId = <a class="code" href="group___components.html#gga0756434f82b03601fec6f5916ee78e5caed1ec45334c97682b945f4285253a639">ILLEGAL_COMP</a>;</div><div class="line">    this-&gt;comp.delete = <a class="code" href="group___components.html#ga24bcba40daa548812854a9add6bb2aa9">_SampleComp_delete</a>;</div><div class="line">    this-&gt;comp.update = <a class="code" href="group___components.html#gac203db290671527d7884287863a723e7">_SampleComp_update</a>;</div><div class="line">    this-&gt;comp.draw = <a class="code" href="group___components.html#gabaa2e55440401af61c0efeec874a21dd">_SampleComp_draw</a>;</div><div class="line">    this-&gt;comp.collides = <span class="keyword">false</span>;</div><div class="line">    this-&gt;comp.coll_resolve = <a class="code" href="group___components.html#gac898ef947fcd43cdb4cf202d50acb61a">_SampleComp_coll_resolve</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___components.html#ga24bcba40daa548812854a9add6bb2aa9">_SampleComp_delete</a>(<a class="code" href="struct_sample_comp.html">SampleComp</a> *<span class="keyword">this</span>) {</div><div class="line">    </div><div class="line">    free(<span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___components.html#gac203db290671527d7884287863a723e7">_SampleComp_update</a>(<a class="code" href="struct_sample_comp.html">SampleComp</a> *<span class="keyword">this</span>) {</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___components.html#gabaa2e55440401af61c0efeec874a21dd">_SampleComp_draw</a>(<a class="code" href="struct_sample_comp.html">SampleComp</a> *<span class="keyword">this</span>) {</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___components.html#gac898ef947fcd43cdb4cf202d50acb61a">_SampleComp_coll_resolve</a>(<a class="code" href="struct_sample_comp.html">SampleComp</a> *<span class="keyword">this</span>, <a class="code" href="struct_component.html">Component</a> *other) {</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="ch1_2"></a>
1.2 - Component Functions</h1>
<p>Another element of C++ classes that is emulated in Processing <a class="el" href="struct_engine.html" title="Contains Engine data. ">Engine</a> is member functions, using function pointers. The <a class="el" href="struct_component.html" title="Object Component. ">Component</a> struct contains several function pointers that are set in substructs to define the behavior of <a class="el" href="struct_component.html" title="Object Component. ">Component</a> s. Some examples of these functions are a delete function, or destructor, and an update function.</p>
<p>Note that the functions (except <code>_[CompName]_new()</code>) all take a pointer called <code>this</code>. This is equivalent to the implicit <code>this</code> parameter in C++ member functions. Now, the difference is that you have to use <code>this</code> to access member data, you cannot omit it.</p>
<p>Any of these functions (except <code>_[CompName]_new()</code>) can be removed from the <a class="el" href="struct_component.html" title="Object Component. ">Component</a>: simply delete it from both the header and source file, and make sure to set the appropriate var of <a class="el" href="struct_component.html" title="Object Component. ">Component</a> in the <code>new</code> function to <code>NULL</code>.</p>
<h2><a class="anchor" id="newfunc"></a>
New Function</h2>
<p>The <code>_[CompName]_new()</code> function is the only function that does not take a <code>this</code> parameter. The reason is that it creates an instance of the <a class="el" href="struct_component.html" title="Object Component. ">Component</a> and returns it.</p>
<p>See <a class="el" href="ch1.html#ch1_3">1.3 - Component New Function</a> for more info.</p>
<h2><a class="anchor" id="delfunc"></a>
Delete Function</h2>
<p>If you allocate any memory for the <a class="el" href="struct_component.html" title="Object Component. ">Component</a>, or just have to cleanup something after a <a class="el" href="struct_component.html" title="Object Component. ">Component</a> gets destroyed, put it in the <code>_[CompName]_delete()</code> function. You must always also free the <a class="el" href="struct_component.html" title="Object Component. ">Component</a> itself after any other cleanup.</p>
<h2><a class="anchor" id="updatefunc"></a>
Update Function</h2>
<p>Any code that updates a <a class="el" href="struct_component.html" title="Object Component. ">Component</a> should be put in the <code>_[CompName]_update()</code> function. This function will be called each game update loop. Use <code>dt()</code> to get delta time in seconds.</p>
<h2><a class="anchor" id="drawfunc"></a>
Draw Function</h2>
<p>Render code should be in the <code>_[CompName]_draw()</code> function. This will also be called each game update, though after everything in the engine has been updated first.</p>
<h2><a class="anchor" id="collresfunc"></a>
Collision Resolution Function</h2>
<p><code>_[CompName]_coll_resolve()</code> is a function that gets called whenever this <a class="el" href="struct_component.html" title="Object Component. ">Component</a> collides with another <a class="el" href="struct_component.html" title="Object Component. ">Component</a>. It takes a <a class="el" href="struct_component.html" title="Object Component. ">Component</a> pointer which is the <a class="el" href="struct_component.html" title="Object Component. ">Component</a> that is collided with. This function is never used if <code>this-&gt;comp.collides</code> is <code>false</code> (see <a class="el" href="ch1.html#ch1_4">1.4 - Component Collisions</a>).</p>
<h1><a class="anchor" id="ch1_3"></a>
1.3 - Component New Function</h1>
<p>This function initializes all of the "superstruct" <a class="el" href="struct_component.html" title="Object Component. ">Component</a> 's data. It sets function pointers, as well as type identification. Other than function pointers, this is all the data it sets:</p>
<p><code>typeName</code> is the stringified name of the <a class="el" href="struct_component.html" title="Object Component. ">Component</a>.<br />
 <code>typeId</code> is a unique id number for the <a class="el" href="struct_component.html" title="Object Component. ">Component</a> (see <a class="el" href="ch1.html#typeid">Type Id</a>).<br />
 <code>collides</code> tells whether this <a class="el" href="struct_component.html" title="Object Component. ">Component</a> should check for collisions.</p>
<h2><a class="anchor" id="typeid"></a>
Type Id</h2>
<p>A <a class="el" href="struct_component.html" title="Object Component. ">Component</a> 's <code>typeId</code> is a unique identification number defined either in <a class="el" href="component_8h.html" title="Object Component. ">Component.h</a> or gamecomps.h. This is what the game-side enum looks like:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> _Game_Comp_TypeId {</div><div class="line">    COMPTYPE1 = <a class="code" href="group___components.html#gga0756434f82b03601fec6f5916ee78e5ca3f6a4856a7d665be9456ceb0ea7d8786">NUM_ENGINE_COMPS</a>,</div><div class="line">    COMPTYPE2,</div><div class="line"></div><div class="line">    NUM_TOTAL_COMPS</div><div class="line">};</div></div><!-- fragment --><p>Game <a class="el" href="struct_component.html" title="Object Component. ">Component</a> type ids start counting right after the last <a class="el" href="struct_engine.html" title="Contains Engine data. ">Engine</a> <a class="el" href="struct_component.html" title="Object Component. ">Component</a>.</p>
<p>Now, in the <code>_[CompName]_new()</code> function, <code>typeId</code> should be set to the enum value defined in this enum, so for example, if the <a class="el" href="struct_component.html" title="Object Component. ">Component</a> is called <code>Player</code>, then the <code>typeId</code> line in the new function should be <code>this-&gt;comp.typeId = PLAYER;</code>.</p>
<h1><a class="anchor" id="ch1_4"></a>
1.4 - Component Collisions</h1>
<p>Only <a class="el" href="struct_component.html" title="Object Component. ">Component</a> s with the <code>collides</code> value set to <code>true</code> will check collisions.</p>
<p><a class="el" href="struct_component.html" title="Object Component. ">Component</a> collisions are handled with functions separate from the <a class="el" href="struct_component.html" title="Object Component. ">Component</a> s themselves. These collision functions are defined in gamecolls.c. To be used by the <a class="el" href="struct_engine.html" title="Contains Engine data. ">Engine</a>, these functions must be registered in the <a class="el" href="struct_engine.html" title="Contains Engine data. ">Engine</a>.</p>
<p>You can also have collision resolution functions that handle collisions between two given <a class="el" href="struct_component.html" title="Object Component. ">Component</a> s arbitrarily. These also need to be registered in the <a class="el" href="struct_engine.html" title="Contains Engine data. ">Engine</a>.</p>
<h2><a class="anchor" id="collcheck"></a>
Collision Checking Functions</h2>
<p>Collision checking functions take the form of <code>static bool CollCheck_[CompName1]_[CompName2](<a class="el" href="struct_component.html" title="Object Component. ">Component</a> *comp1, <a class="el" href="struct_component.html" title="Object Component. ">Component</a> *comp2)</code>. It is important to note that <em>comp1 and comp2 aren't necessarily of the corresponding types</em>. This is where <code>INITCOLLCOMPS</code> comes in handy (see <a class="el" href="ch1.html#initcollcomps">INITCOLLCOMPS</a>). Once that is taken care of, you can use the two pointers however you need, and return <code>true</code> if collision happened, or <code>false</code> if it didn't.</p>
<h2><a class="anchor" id="collresolve"></a>
Collision Resolving Functions</h2>
<p>Collision resolving functions take the form of <code>static bool CollResolve_[CompName1]_[CompName2](<a class="el" href="struct_component.html" title="Object Component. ">Component</a> *comp1, <a class="el" href="struct_component.html" title="Object Component. ">Component</a> *comp2)</code>. Collision resolving functions are similar to checking functions, except you do not need to return anything (see <a class="el" href="ch1.html#initcollcomps">INITCOLLCOMPS</a>).</p>
<h2><a class="anchor" id="initcollcomps"></a>
INITCOLLCOMPS</h2>
<p>Here is an example collision checking function template:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> CollCheck_CompType1_CompType2(<a class="code" href="struct_component.html">Component</a> *comp1, <a class="code" href="struct_component.html">Component</a> *comp2) {</div><div class="line">    CompType1 *type1;</div><div class="line">    CompType2 *type2;</div><div class="line">    <a class="code" href="group___util.html#ga4425670096f46452737223f56b0ebe78">INITCOLLCOMPS</a>(COMPTYPE1, type1, type2, comp1, comp2);</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>INITCOLLCOMPS takes the <a class="el" href="struct_component.html" title="Object Component. ">Component</a> type id of the first <a class="el" href="struct_component.html" title="Object Component. ">Component</a> type (<code>CompType1</code> in this case), the two pointers you want to initialize, and the two <a class="el" href="struct_component.html" title="Object Component. ">Component</a> pointers passed into the function. It then sorts the two <a class="el" href="struct_component.html" title="Object Component. ">Component</a> s, such that the first variable pointer passed in is set to the one of the two <a class="el" href="struct_component.html" title="Object Component. ">Component</a> pointers whose type id is equal to the given type id.</p>
<h2><a class="anchor" id="collfuncreg"></a>
Registering Collision Functions</h2>
<p>To register collision checking or resolving functions with the <a class="el" href="struct_engine.html" title="Contains Engine data. ">Engine</a>, you need to use two different functions in gamecolls.c, like so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> listColls() {</div><div class="line">    <a class="code" href="group___util.html#ga2b875936e7863a6bb59cdc432981c743">Engine_addCollCheckFunc</a>(COMPTYPE1, COMPTYPE2, CollCheck_CompType1_CompType2);</div><div class="line">    <a class="code" href="group___util.html#ga2d2600837690ceac53ba92c9ab28f3e4">Engine_addCollResolveFunc</a>(COMPTYPE1, COMPTYPE2, CollResolve_CompType1_CompType2);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
